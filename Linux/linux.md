# Linux

**Дистрибуив** - установочный файл для какой-то программы.
Файловая система используется для хранения и управления файлами на жетском диске компьютере.  
Жесткий диск разбивается на разделы.  
На диске всегда есть первичный (основной) раздел, куда устанавливается ОС.   
Каждый раздел имеет файловую систему.  

Файловые системы для Linux: ext2, ext3, ext4  
Файловые системы для Windows: NTFS, FAT   

dev/sda[1-4] - разделы   
Жесткий диск может быть разделен только на 4 основных раздела. Раздел можно разделить еще.   

**Системный раздел** - там устанавливается linux, пользовательские файлы.  
- Раздел подкачки - только для ОС.   
- Пользовательский раздел - домашние каталоги юзера.  

**Вируальная машина** - это программно воссозданный компьютер. Использует мощность реального компьютера.
**Репазиторий** - хранилище программ, которые готовы к установке. Уже есть гарантия надежности.   

Каталоги Linux:
| Каталог |                              Описание                                     |
|---------|---------------------------------------------------------------------------|
| /home   |  домашний каталог                                                         | 
| /bin    |  двоичные приложения                                                      | 
| /boot   |  загрузка ОС                                                              | 
| /cdrom  |  место для монтирования cd дисков                                         | 
| /dev    |  устройства                                                               | 
| /etc    |  конфигурационные файлы ОС. Настройки                                     | 
| /lib    |  системные библиотеки                                                     | 
| /media  |  подсоединенные к компьютеру сменные съемные носитеи информации (флешки)  | 
| /mnt    |  временная точка монтирования для жетских или оптических дисков           | 
| /opt    |  подкаталоги дополнительных программ                                      | 
| /proc   |  содержит свеления о состоянии системы, в том числе запущенные процессы   | 
| /root   |  каталог суперпользователя                                                | 
| /run    |  установленные программы могу хранить тут вспомогательные временные файлы | 
| /sbin   |  двоичные системные программы                                             | 
| /srv    |  храняться данные, используемые серверами                                 | 
| /sys    |  хранит данные о системе                                                  | 
| /tmp    |  хранение временных файлов Имеют доступ все пользователи                  | 
| /usr    |  сюда устанавливаются программы                                           | 
| /var    |  хранение частых изменяющих данных (кеши, журналы событий, бд)            | 

**Менеджер пакетов Synaptic** - установка и удаление пакетов 

[имя команды][параметры][аргументы]   
**Средние значения нагрузки в Linux** — это «средние значения нагрузки системы», показывающие потребность в исполняемых потоках (задачах) в виде усреднённого количества исполняемых и ожидающих потоков.     
Это мера нагрузки, которая может превышать обрабатываемую системой в данный момент. Большинство инструментов показывает три средних значения: для 1, 5 и 15 минут:   
```
$ uptime
 16:48:24 up  4:11,  1 user,  load average: 25.25, 23.40, 23.46
```

Некоторые интерпретации:  
Если значения равны 0.0, то система в состоянии простоя.   
Если среднее значение для 1 минуты выше, чем для 5 или 15, то нагрузка растёт.   
Если среднее значение для 1 минуты ниже, чем для 5 или 15, то нагрузка снижается.  
Если значения нагрузки выше, чем количество процессоров, то у вас могут быть проблемы с производительностью (в зависимости от ситуации).  

В Linux средние нагрузки — это (или пытаются быть) «средние значения нагрузки на систему», систему в целом.   
Они измеряют количество выполняемых потоков и ожидающих своей очереди (процессор, диск, непрерываемые блокировки).   
Иными словами, эта метрика отражает количество потоков, которые не простаивают полностью. Преимущество: учитывается потребность в разных ресурсах.  

В других ОС средние нагрузки — это «средние значения нагрузки на процессор». Они измеряют количество потоков, выполняемых и готовых к выполнению в процессоре.   
Преимущество: проще в понимании и обосновании (только для процессоров).  

**Команды:**
- Использование каждого процессора (per-CPU utilization): например, используя mpstat -P ALL 1.
- Использование процессора для каждого процесса (per-process CPU utilization): например, top, pidstat 1 и так далее.
- Задержка очереди выполнения (диспетчера) для каждого потока (per-thread run queue (scheduler) latency): например, в /proc/PID/schedstats, delaystats, perf sched
- Задержка очереди выполнения процессора (CPU run queue latency): например, в /proc/schedstat, perf sched, моём инструменте runqlat bcc.
- Длина очереди выполнения процессора (CPU run queue length): например, используя vmstat 1 и колонку 'r', или мой инструмент runqlen bcc.

**Значения Load Average:**
- 0.00 означает, что на мосту нет ни одной машины. Фактически, значения от 0.00 до 1.00 означают отсутствие очереди.  
- 1.00 означает, что на мосту находится как раз столько автомобилей, сколько он может вместить. Все еще идет хорошо, но, в случае увеличения потока машин, возможны проблемы;  
- Значения, превышающие 1.00 означают наличие очереди на въезде. Насколько большой? Например, значение 2.00 показывает, что в очереди стоит столько же автомобилей, сколько движется по мосту.   
3.00 означает, что мост полностью занят и в очереди ожидает в два раза больше машин, чем он может вместить. И так далее.  

Сколько ядер в системе?
```
cat /proc/cpuinfo | grep 'cpu cores'
```

**Выбор процесса:**  
Когда заканчивается память, вызывается функция out_of_memory(). В ней есть функция select_bad_process(), которая получает оценку от функции badness(). Под раздачу попадет самый «плохой» процесс. Функция badness() выбирает процесс по определенным правилам.
1. Ядру нужен какой-то минимум памяти для себя.
2. Нужно освободить много памяти.
3. Не нужно завершать процессы, которые используют мало памяти.
4. Нужно завершить минимум процессов.
5. Сложные алгоритмы, которые повышают шансы на завершение для тех процессов, которые пользователь сам хочет завершить.

**SWAP** — это механизм виртуальной памяти, при котором часть данных из оперативной памяти (ОЗУ) перемещается на хранение на HDD (жёсткий диск), SSD (твёрдотельный накопитель).

**Своппинг необходим по следующим причинам:**
- Когда системе необходимо больше памяти (т.е. приложение или процесс запрашивает у системы больше памяти) чем сейчас свободно в ОЗУ, ядро разгружает (”откачивает”) наименее используемые страницы и освобожденную память выделяет текущему приложению или процессу.
- Значительное количество страниц используемых программами на стадии запуска, используются только при инициализации и никогда более. Соответственно система может засвопить эти страницы, тем самым освобождая (разгружая) ОЗУ
